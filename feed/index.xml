<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>ZGGSONG WIKI</title><link>/</link><description>简单的记录学习.</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.jsdelivr.net/gh/ZGGSONG/zggsong.github.io@master/logo.png</url><title>ZGGSONG WIKI</title><link>/</link></image><language>zh-CN</language><lastBuildDate>Tue, 06 Jul 2021 08:11:35 +0806</lastBuildDate><pubDate>Tue, 06 Jul 2021 08:11:35 +0806</pubDate><item><title>fzf安装配置</title><link>/archives/fzf/</link><description>&lt;h2&gt;安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install fzf
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;快捷键安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$(brew --prefix)/opt/fzf/install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装好后按照提示刷新&lt;code&gt;shell&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;配置&lt;/h2&gt;
&lt;h3&gt;zshrc&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#export FZF_DEFAULT_OPTS='--bind=ctrl-t:top,change:top --bind ctrl-e:down,ctrl-u:up'
export FZF_DEFAULT_OPTS='--bind ctrl-e:down,ctrl-u:up --preview &amp;quot;[[ $(file --mime {}) =~ binary ]] &amp;amp;&amp;amp; echo {} is a binary file || (ccat --color=always {} || highlight -O ansi -l {} || cat {}) 2&amp;gt; /dev/null | head -500&amp;quot;'
#export FZF_DEFAULT_COMMAND='ag --hidden --ignore .git -g &amp;quot;&amp;quot;'
export FZF_DEFAULT_COMMAND='fd'
export FZF_COMPLETION_TRIGGER='\'
export FZF_TMUX=1
export FZF_TMUX_HEIGHT='80%'
export fzf_preview_cmd='[[ $(file --mime {}) =~ binary ]] &amp;amp;&amp;amp; echo {} is a binary file || (ccat --color=always {} || highlight -O ansi -l {} || cat {}) 2&amp;gt; /dev/null | head -500'
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ranger&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rc.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;map &amp;lt;C-f&amp;gt; fzf_select
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;commands.py&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class fzf_select(Command):
    &amp;quot;&amp;quot;&amp;quot;
    :fzf_select
    Find a file using fzf.
    With a prefix argument select only directories.
    See: https://github.com/junegunn/fzf
    &amp;quot;&amp;quot;&amp;quot;
    def execute(self):
        import subprocess
        import os.path
        if self.quantifier:
            # match only directories
            command = &amp;quot;find -L . \( -path '*/\.*' -o -fstype 'dev' -o -fstype 'proc' \) -prune \
            -o -type d -print 2&amp;gt; /dev/null | sed 1d | cut -b3- | fzf +m&amp;quot;

        else:
            # match files and directories
            command = &amp;quot;find -L . \( -path '*/\.*' -o -fstype 'dev' -o -fstype 'proc' \) -prune \
            -o -print 2&amp;gt; /dev/null | sed 1d | cut -b3- | fzf +m&amp;quot;

        fzf = self.fm.execute_command(command,
                                      universal_newlines=True,
                                      stdout=subprocess.PIPE)
        stdout, stderr = fzf.communicate()
        if fzf.returncode == 0:
            fzf_file = os.path.abspath(stdout.rstrip('\n'))
            if os.path.isdir(fzf_file):
                self.fm.cd(fzf_file)
            else:
                self.fm.select_file(fzf_file)
&lt;/code&gt;&lt;/pre&gt;
</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/fzf/</guid><pubDate>Sun, 23 Aug 2020 17:27:00 +0806</pubDate></item><item><title>Unix网络编程复习</title><link>/archives/unix_network/</link><description>&lt;h1&gt;LNP作业1&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年2月17号 星期一 08:55&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU是什么词组的缩写？&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;答：&lt;ul&gt;
&lt;li&gt;GNU's Not Unix&lt;/li&gt;
&lt;li&gt;^-----^---^---&lt;/li&gt;
&lt;li&gt;箭头指向的那个那个字母：G N U&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;LNP作业2&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年2月20号 星期四 11:01&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux中目录/proc存储的是什么信息？&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;答：&lt;ul&gt;
&lt;li&gt;Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。&lt;/li&gt;
&lt;/ul&gt;
用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的。下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在/proc下还有三个很重要的目录：net，scsi和sys。 Sys目录是可写的，可以通过它来访问或修改内核的参数，而net和scsi则依赖于内核配置。例如，如果系统不支持scsi，则scsi 目录不存在。
除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的 PID号为目录名，它们是读取进程信息的接口。而self目录则是读取进程本身的信息接口，是一个link。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;LNP作业3&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年3月2号 星期一 08:56&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;写一个C程序: 生成10个子进程并利用waitpid回收，父进程回收子进程时输出子进程的PID.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;WNOHNAG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;threadCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 生成10个子进程并利用waitpid回收，父进程回收子进程时输出子进程的PID.&lt;/span&gt;
  &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;threadCount&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//子进程&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;child[%d] created...(sleep 1s)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="mf"&gt;-0.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//测试waitpid是否生效&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//父进程&lt;/span&gt;
      &lt;span class="c1"&gt;//&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;threadCount&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//父进程&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;threadCount&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;threadCountTemp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threadCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent waiting child...&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threadCountTemp&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;threadCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;waitpid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;WNOHNAG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;gt;&amp;gt;child[%d] done,pid = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
          &lt;span class="n"&gt;threadCountTemp&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编译脚本&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; start ---------\n&amp;quot;&lt;/span&gt;
g++ -o &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt;.c &lt;span class="sb"&gt;`&lt;/span&gt;mysql_config --cflags --libs&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;./&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; end ---------\n&amp;quot;&lt;/span&gt;
rm &lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;div class="photoset"&gt;&lt;div class="photos"&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="876" data-height="644" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200312150535" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;div class="photos"&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="836" data-height="133" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200312150553" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;LNP作业4&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;统计已经安装好虚拟机的人数,安装好的提交作业,没装好不要提交,本周末之前提交&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;答：&lt;ul&gt;
&lt;li&gt;已安装&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;LNP作业5&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;写一对基于UDP的服务器客户端程序。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;客户端可以用命令&lt;code&gt;./udpclient &amp;lt;IP&amp;gt; &amp;lt;number&amp;gt;&lt;/code&gt;执行
并在标准输出上输出&lt;code&gt;number + 1&lt;/code&gt;
服务器在约定的本地套接字上等待客户端消息，加1操作后发送给客户端
&lt;code&gt;先来先服务&lt;/code&gt;
直接在作业中粘贴两端代码，include部分只粘贴一次&lt;/p&gt;&lt;h2&gt;代码&lt;/h2&gt;
&lt;h2&gt;服务端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

  &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BIND_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30303&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 创建fd&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;创建文件描述符失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 配置&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// IPV4&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inet_addr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// IP&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_PORT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// PORT&lt;/span&gt;
    &lt;span class="c1"&gt;// 绑定&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;监听失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;src_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addr_len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
      &lt;span class="c1"&gt;//接收数据和来源的ip地址&lt;/span&gt;
      &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;src_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Recv:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="c1"&gt;// char*转int&lt;/span&gt;
      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="c1"&gt;// +1操作&lt;/span&gt;
      &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// int转char*&lt;/span&gt;
      &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="c1"&gt;// 发送数据给目标地址&lt;/span&gt;
      &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;src_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="c1"&gt;//关闭socket对象&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;服务端编译脚本&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; start ---------\n&amp;quot;&lt;/span&gt;
  g++ -o &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt;.c &lt;span class="sb"&gt;`&lt;/span&gt;mysql_config --cflags --libs&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;./&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; end ---------\n&amp;quot;&lt;/span&gt;
  rm &lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
  &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;参数不足&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;创建文件描述符失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30303&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inet_addr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addr_len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
        &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Recv:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;// 一次就结束&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端编译脚本&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; start ---------\n&amp;quot;&lt;/span&gt;
  g++ -o &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt;.c &lt;span class="sb"&gt;`&lt;/span&gt;mysql_config --cflags --libs&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;./&lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="nv"&gt;$3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; end ---------\n&amp;quot;&lt;/span&gt;
  rm &lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;div class="photoset"&gt;&lt;div class="photos"&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="1019" data-height="176" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200312151313" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;div class="photos"&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="1117" data-height="179" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200312151323" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;3.10 并发服务器实验&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年3月10号 星期二 15:16&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在3月8日课程内容的基础上修改并发服务器和对应客户端的代码，使得服务端可以返回客户端发送的两个整数之和。服务器提供并发服务。这次作业的代码也是实验二的代码。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;服务端代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BIND_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30303&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 创建fd&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;创建文件描述符失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;// 配置&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
  &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// IPV4&lt;/span&gt;
  &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inet_addr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// IP&lt;/span&gt;
  &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_PORT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// PORT&lt;/span&gt;
  &lt;span class="c1"&gt;// 绑定&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;监听失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;src_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addr_len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
    &lt;span class="c1"&gt;//接收数据和来源的ip地址&lt;/span&gt;
    &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;src_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Recv:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// char*转int&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret_res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Return:%d + %d = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ret_res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// int转char*&lt;/span&gt;
      &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret_res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="c1"&gt;// 发送数据给目标地址&lt;/span&gt;
      &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;src_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;//关闭socket对象&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BIND_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30303&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SOCK_DGRAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;创建文件描述符失败&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
  &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_PORT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inet_addr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;addr_len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
      &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
      &lt;span class="n"&gt;sendto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
      &lt;span class="n"&gt;recvfrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;saddrp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;addr_len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Recv:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;recv_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="c1"&gt;// 一次就结束&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;div class="photoset"&gt;&lt;div class="photos"&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="1020" data-height="189" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200313143557.png" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;div class="photos"&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="1017" data-height="172" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200313143622.png" alt="" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;/div&gt;&lt;h1&gt;3.10 实现popen&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年3月10号 星期二 15:21&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;实验一. 实现程序mypopen&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;以此shell命令为例
&lt;code&gt;#./mypopen ls -l&lt;/code&gt;
父进程首先创建pipe管道；
父进程创建子进程；
子进程执行ls -l；
子进程的输出经管道传给父进程；
父进程，将子进程的信息输出在标准输出上&lt;/p&gt;&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt;  &lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;limits.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt;  &lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* 模拟popen */&lt;/span&gt;
&lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;mypopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* 调试 */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[]){&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;请输入指令&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;// 最多支持10个参数&lt;/span&gt;
  &lt;span class="c1"&gt;// 构造新数组，提取第二个及后面的参数赋给新数组(cmd)，并在令新数组最后一个数组值为NULL&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;You Exe Cmd: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="c1"&gt;// 非阻塞执行指令&lt;/span&gt;
  &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mypopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// 输出结果&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;无效的指令&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fgetc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;putchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fgetc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* 模拟popen */&lt;/span&gt;
&lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;mypopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 0读 1写&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="kt"&gt;pid_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 进程描述符                 &lt;/span&gt;

  &lt;span class="c1"&gt;// 其他参数为非法&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;r&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;  
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myopen() illegal param type, must be &amp;#39;r&amp;#39; or &amp;#39;w&amp;#39;/n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;  

  &lt;span class="c1"&gt;// 建立管道  &lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pipe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myopen() pipe create error/n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// 建立子进程  &lt;/span&gt;
  &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             

  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 子进程执行命令&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;  
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// 关闭读管道&lt;/span&gt;
      &lt;span class="c1"&gt;// dup2(fd[1],STDOUT_FILENO);&lt;/span&gt;
      &lt;span class="n"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  &lt;span class="c1"&gt;// 将标准输出重定向到管道写端&lt;/span&gt;
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// 使用完毕，关闭管道&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// 关闭写管道，父进程来以子写&lt;/span&gt;
      &lt;span class="c1"&gt;// dup2(fd[0],STDIN_FILENO);&lt;/span&gt;
      &lt;span class="n"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// 将标准输出重定向到管道读端&lt;/span&gt;
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// 使用完毕，关闭管道&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;execvp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;//用exec族函数执行命令  &lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 父进程等待子进程返回  &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;r&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 程序需要返回的参数是文件指针，因此需要用 fdopen 函数将描述符打开，其返回值为相应的文件指针   &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
      &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编译脚本&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
echo &amp;quot;\n--------- project $1 start ---------\n&amp;quot;
g++ -o $1 $1.c `mysql_config --cflags --libs`;./$@;echo &amp;quot;\n--------- project $1 end ---------\n&amp;quot;
rm $1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;mypopen源程序的设计中，规定了参数不得超过10个&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;指令（包含指令名称）参数为1时&lt;/h2&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1169" data-height="191" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200313143948.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;指令（包含指令名称）参数为2时&lt;/h2&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1168" data-height="388" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200313144055.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;指令（包含指令名称）参数为n(n&amp;lt;=10)时&lt;/h2&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1166" data-height="288" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200313145725.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;dup与dup2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;APUE和man文档都用一句话简明的说出了这两个函数的作用：复制一个现存的文件描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;oldfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;dup2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;oldfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;newfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。&lt;/li&gt;
&lt;li&gt;dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。&lt;/li&gt;
&lt;li&gt;APUE用另外一个种方法说明了这个问题：&lt;ul&gt;
&lt;li&gt;实际上，调用dup(oldfd)等效于，&lt;code&gt;fcntl(oldfd, F_DUPFD, 0);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;而调用dup2(oldfd, newfd)等效于，&lt;code&gt;close(oldfd);fcntl(oldfd, F_DUPFD, newfd);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/silent123go/article/details/71108501"&gt;linux之dup和dup2函数解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/qq_37098914/article/details/80141458"&gt;warning：deprecated conversion from string constant to 'char *'解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/ssdsafsdsd/article/details/8159365"&gt;execvp()函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cnblogs.com/chjbbs/p/6393805.html"&gt;linux bash Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3.19 select&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年3月19号 星期四 11:04&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个基于select函数的程序：mycp，其使用方式为：&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;./mycp filename1 filename2
运行结果是filename2是被复制的filename1，两者内容相同。
文件操作相关调用open, read, write,close可查阅Linux课程教材
注意因为要使用select，所以不要用文件流指针处理文件。&lt;/p&gt;&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/select.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mycp require two params&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// const char * pathname = &amp;quot;./test&amp;quot;;&lt;/span&gt;
  &lt;span class="c1"&gt;// const char * pathname_cp = &amp;quot;./testcp&amp;quot;;&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pathname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pathname_cp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;access&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no access to read / no such file&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fd_cp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 一个一个的读，只要读到\0那么就说明结束了&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret_cp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;fd_cp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pathname_cp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;O_WRONLY&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;O_CREAT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;fd_set&lt;/span&gt; &lt;span class="n"&gt;readfds&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;FD_ZERO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readfds&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;FD_SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readfds&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 加入到轮询列表&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="c1"&gt;// 阻塞&lt;/span&gt;
    &lt;span class="n"&gt;sret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;readfds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// &amp;amp;timeout&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;sret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sret = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;    error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// printf(&amp;quot;sret = %d\n&amp;quot;, sret);&lt;/span&gt;
      &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 停止轮询条件&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;ret_cp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd_cp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="c1"&gt;// printf(&amp;quot;ret_cp = %d\n&amp;quot;, ret_cp);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret_cp&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ret = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;    error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;调试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;输入参数错误时&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1170" data-height="46" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200322174602.png" alt="" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;输入的文件不存在/当前用户无读权限&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1167" data-height="306" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200322175201.png" alt="" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;测试复制test文件&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1170" data-height="163" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200322175258.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/songyulong8888/article/details/80719225"&gt;Linux C 判断文件是否存在，是否可读，可写，可执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/eleanor_12/article/details/53164860"&gt;Linux C——select函数详解及其应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cnblogs.com/ace-wu/p/6640186.html"&gt;Linux下C语言open函数打开或创建文件与read，write函数详细讲解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=qyFwGyTYe-M"&gt;C Programming in Linux Tutorial #083 - select() function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhidao.baidu.com/question/1898495212476037140.html"&gt;Linux打开的文件描述符必须手动close吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="div2img-epoll-client"&gt;
  &lt;h1&gt;测试&lt;/h1&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;!-- &lt;button onclick="div2img('div2img-epoll-client')"&gt;下载截图&lt;/button&gt; --&gt;
&lt;p&gt;&lt;button id="btn"&gt;下载截图&lt;/button&gt;&lt;/p&gt;&lt;div id="test-btn"&gt;
  &lt;h1&gt;Test&lt;/h1&gt;
&lt;/div&gt;
&lt;h1&gt;epoll client&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2020年3月23号 星期一 09:07&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;请利用epoll函数改写基于TCP的回音客户端，注意使用边缘触发模式，管理标准输入和套接字描述符。回音客户端和服务端的代码在教材源代码包中，本次作业仅需修改客户端，基于epoll的服务端将作为第三次实验的内容。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;客户端代码（使用epoll监听文件描述符）&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt; //close()&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt; //strcmp()等字符串操作函数&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt; //atoi() 字符串转int&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BIND_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30303&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="c1"&gt;// 1 创建tcp通信socket&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;socket failed!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// 2 连接服务器&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;server_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="c1"&gt;//服务器的地址信息&lt;/span&gt;
  &lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//IPv4协议&lt;/span&gt;
  &lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_PORT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//服务器端口号&lt;/span&gt;
  &lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inet_addr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_SERVER_IP&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//设置服务器IP&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connect failed!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connect server successful!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// 创建epoll监听连接TCP的文件描述符是否可读&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;epfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nfds&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;epoll_event&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 最多存三个触发，本例中实际上只会占用一个&lt;/span&gt;
  &lt;span class="n"&gt;epfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;epoll_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 监听连接服务器的TCP文件描述符&lt;/span&gt;
  &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPOLLIN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;EPOLLET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 是否可都 + 边缘触发（描述符由不可读变为可读，只通知一次）&lt;/span&gt;
  &lt;span class="n"&gt;epoll_ctl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EPOLL_CTL_ADD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 注册&lt;/span&gt;

    &lt;span class="c1"&gt;//3 循环发送消息、接收消息&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;say something:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// scanf(&amp;quot;%s&amp;quot;,buf); // 不识别空格&lt;/span&gt;
    &lt;span class="c1"&gt;// gets(buf); // 不安全&lt;/span&gt;
    &lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%[^&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;]%*c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 识别空格&lt;/span&gt;
    &lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//发送消息&lt;/span&gt;
    &lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="c1"&gt;// read(socket_fd, buf, sizeof(buf)); //阻塞，等待客户端发来消息&lt;/span&gt;
    &lt;span class="n"&gt;nfds&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;epoll_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 非阻塞监听回信&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;nfds&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// printf(&amp;quot;hello world\n&amp;quot;);&lt;/span&gt;
        &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Receive: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;exit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//退出循环&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;//4 关闭socket&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;附：服务端代码（单线程服务端）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;服务端的作用是把客户端发来的消息再发回去，实现“回音”效果&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt; //close()&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt; //strcmp()等字符串操作函数&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt; //atoi() 字符串转int&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// const char* BIND_SERVER_IP = &amp;quot;127.0.0.1&amp;quot;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BIND_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30303&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[]){&lt;/span&gt;

  &lt;span class="c1"&gt;//1 创建tcp通信socket&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;创建tcp通信socket失败!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;//2 绑定socket地址&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;server_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="c1"&gt;//存放地址信息&lt;/span&gt;
  &lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_family&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AF_INET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//AF_INET-&amp;gt;IPv4  &lt;/span&gt;
  &lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;htons&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIND_PORT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//端口号&lt;/span&gt;
  &lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;INADDR_ANY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//让系统检测本地网卡，自动绑定本地IP&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server_addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bind failed!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;//3 设置监听队列，设置为可以接受5个客户端连接&lt;/span&gt;
  &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;listen falied!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;server is running!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr_in&lt;/span&gt; &lt;span class="n"&gt;client_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="c1"&gt;//用来存放客户端的地址信息&lt;/span&gt;
  &lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;new_socket_fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//存放与客户端的通信socket&lt;/span&gt;

  &lt;span class="c1"&gt;//4 等待客户端连接&lt;/span&gt;
  &lt;span class="n"&gt;new_socket_fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;sockaddr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;client_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_socket_fd&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;accpet error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;IP:%s, PORT:%d [connected]&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inet_ntoa&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_addr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client_addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin_port&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//循环接收信息&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//阻塞，,等待客户端发来消息&lt;/span&gt;
    &lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//发送消息&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;receive msg:%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//打印消息&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;exit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//退出循环&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;//5 关闭socket&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_socket_fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编译脚本&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; start ---------\n&amp;quot;&lt;/span&gt;
g++ -o &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt;.c&lt;span class="p"&gt;;&lt;/span&gt;./&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n--------- project &lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; end ---------\n&amp;quot;&lt;/span&gt;
rm &lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1160" data-height="268" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200329163233.png" alt="" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1166" data-height="243" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200329163257.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;相关知识点&lt;/h2&gt;
&lt;h3&gt;epoll机制: epoll_create、epoll_ctl、epoll_wait&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;引入&lt;code&gt;sys/epoll.h&lt;/code&gt;依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1. 创建epoll句柄&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;epfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;epoll_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;size用来告诉内核这个监听的数目一共有多大&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4&gt;2. 将被监听的描述符添加到epoll句柄或从epool句柄中删除或者对监听事件进行修改&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;epoll_ctl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;epfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;epoll_event&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;ul&gt;
&lt;li&gt;epfd：由 epoll_create 生成的epoll专用的文件描述符；&lt;/li&gt;
&lt;li&gt;op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除&lt;/li&gt;
&lt;li&gt;fd：关联的文件描述符；&lt;/li&gt;
&lt;li&gt;event：指向epoll_event的指针；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个参数是epoll_create()的返回值&lt;/p&gt;&lt;p&gt;第二个参数表示动作，用三个宏来表示:
|||
|-|-|
|EPOLL_CTL_ADD|注册新的fd到epfd中|
|EPOLL_CTL_MOD|修改已经注册的fd的监听事件|
|EPOLL_CTL_DEL|从epfd中删除一个fd|&lt;/p&gt;&lt;p&gt;第三个参数是需要监听的fd&lt;/p&gt;&lt;p&gt;第四个参数是告诉内核需要监听什么事件，structepoll_event结构如下：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="nc"&gt;epoll_data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;__uint32_t&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;__uint64_t&lt;/span&gt; &lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;epoll_data_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;epoll_event&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;__uint32_t&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* Epoll events */&lt;/span&gt;
&lt;span class="n"&gt;epoll_data_t&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* User data variable */&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;events可以是以下几个宏的集合：
|||
|-|-|
|EPOLLIN|触发该事件，表示对应的文件描述符上有可读数据。(包括对端SOCKET正常关闭)；|
|EPOLLOUT|触发该事件，表示对应的文件描述符上可以写数据；|
|EPOLLPRI|表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；|
|EPOLLERR|表示对应的文件描述符发生错误；|
|EPOLLHUP|表示对应的文件描述符被挂断；|
|EPOLLET|将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的；|
|EPOLLONESHOT|只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。|&lt;/p&gt;&lt;h4&gt;3.等待事件触发，当超过timeout还没有事件触发时，就超时。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;epoll_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;epfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;epoll_event&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxevents&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数用于轮询I/O事件的发生，即等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大(数组成员的个数)，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1为阻塞）。&lt;/p&gt;&lt;p&gt;该函数返回需要处理的事件数目，如返回0表示已超时。&lt;/p&gt;&lt;p&gt;返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。返回0表示已经超时。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;epfd:由epoll_create 生成的epoll专用的文件描述符；&lt;/li&gt;
&lt;li&gt;epoll_event:用于回传代处理事件的数组；&lt;/li&gt;
&lt;li&gt;maxevents:每次能处理的事件数；&lt;/li&gt;
&lt;li&gt;timeout: 等待I/O事件发生的超时值。-1相当于阻塞，0相当于非阻塞。一般用-1即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回发生事件数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4. ET与LT&lt;/h4&gt;
&lt;p&gt;EPOLL事件有两种模型：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;ET：边缘触发模式&lt;/li&gt;
&lt;li&gt;LT：水平触发模式&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;Edge Triggered(ET)&lt;/td&gt;
  &lt;td&gt;高速工作方式，错误率比较大，只支持no_block socket (非阻塞socket)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;LevelTriggered(LT)&lt;/td&gt;
  &lt;td&gt;缺省工作方式，即默认的工作方式,支持blocksocket和no_blocksocket，错误率比较小。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;水平触发&lt;/h4&gt;
&lt;h5&gt;1. 对于读操作&lt;/h5&gt;
&lt;p&gt;只要缓冲内容不为空，LT模式返回读就绪。&lt;/p&gt;&lt;h5&gt;2. 对于写操作&lt;/h5&gt;
&lt;p&gt;只要缓冲区还不满，LT模式会返回写就绪。&lt;/p&gt;&lt;h4&gt;边缘触发&lt;/h4&gt;
&lt;h5&gt;1. 对于读操作&lt;/h5&gt;
&lt;p&gt;（1）当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。&lt;/p&gt;&lt;p&gt;（2）当有新数据到达时，即缓冲区中的待读数据变多的时候。&lt;/p&gt;&lt;p&gt;（3）当缓冲区有数据可读，且应用进程对相应的描述符进行&lt;code&gt;EPOLL_CTL_MOD&lt;/code&gt;修改&lt;code&gt;EPOLLIN&lt;/code&gt;事件时。&lt;/p&gt;&lt;h5&gt;2. 对于写操作&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;（1）当缓冲区由不可写变为可写时。&lt;/li&gt;
&lt;li&gt;（2）当有旧数据被发送走，即缓冲区中的内容变少的时候。&lt;/li&gt;
&lt;li&gt;（3）当缓冲区有空间可写，且应用进程对相应的描述符进行&lt;code&gt;EPOLL_CTL_MOD&lt;/code&gt;修改&lt;code&gt;EPOLLOUT&lt;/code&gt;事件时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/lihao21/article/details/67631516?depth_1-utm_source=distribute.pc_relevant.none-task&amp;amp;utm_source=distribute.pc_relevant.none-task"&gt;epoll 水平触发与边缘触发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/weixin_34072637/article/details/88567356?depth_1-utm_source=distribute.pc_relevant.none-task&amp;amp;utm_source=distribute.pc_relevant.none-task"&gt;C++回声服务器_9-epoll边缘触发模式版本服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/yusiguyuan/article/details/15027821"&gt;epoll机制:epoll_create、epoll_ctl、epoll_wait、close&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1&gt;Producer vs. Consumer --Circular Queue&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;题量： 1
满分： 100 分
创建者：李沁
截止时间：2020-04-09 10:00
作业改写成环形缓存队列&lt;/p&gt;&lt;/blockquote&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="2708" data-height="1658" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200407182842.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[x] 所给的代码截图采用生产者-缓存Quene-消费者模式在多线程并发场景下处理数据。&lt;/li&gt;
&lt;li&gt;[x] 生产者一个线程，消费者一个线程，共用缓存队列。&lt;/li&gt;
&lt;li&gt;[x] 生产者负责制造（接收）待处理数据，向缓存中添加数据。消费者负责处理待处理数据，从缓存中取出数据并销毁或标记为可用状态。两个线程相互独立，仅在操作缓存队列时需要相互避让。&lt;/li&gt;
&lt;li&gt;线程之间通过信号量进行避让操作，避免同时操作缓存引起脏数据。&lt;/li&gt;
&lt;li&gt;[x] 生产者线程、消费者线程、缓存队列三者相辅相成，构成有机整体，可以异步处理多线程并发问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;改用环形队列作为队列缓存的数据结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[x] 代码参考了老师给的代码思路，自己重写模拟生产者消费者模型。&lt;/li&gt;
&lt;li&gt;[x] 改用环形队列作为缓存(RingBuffer)。&lt;/li&gt;
&lt;li&gt;[x] RingBuffer采用数组实现，最大可提供得并发访问由&lt;code&gt;MAX_COUNT&lt;/code&gt;决定。&lt;/li&gt;
&lt;li&gt;[x] 模型通过异步向数据库插入学生信息（姓名、学号、班级）。向数据库插入数据通过&lt;u&gt;&lt;strong&gt;线程延迟10ms模拟&lt;/strong&gt;&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;[x] 公共变量采用&lt;code&gt;pthread&lt;/code&gt;的互斥锁保证数据完整。&lt;/li&gt;
&lt;li&gt;[x] 实现环形缓存的关键函数：&lt;code&gt;getRingBufferIndex(requestID)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[x] 如果ringBuffer容量已满，会直接丢弃请求&lt;/li&gt;
&lt;li&gt;[x] &lt;code&gt;thread3, thread4&lt;/code&gt;相关代码默认注释状态，用来测试连续两次有较长时间间隔的&lt;code&gt;并发请求数 &amp;gt; 缓存最大容量&lt;/code&gt;时的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码1-定义环形缓存ringBuffer&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#ifndef ringBuffer_h
#define ringBuffer_h

// insert into db
// 待处理的数据格式
typedef struct {
  char *stu_name;  // 姓名
  char *stu_stuID; // 学号
  int age;     // 年龄
} StuInfo;

// ringBuffer item
// 环形队列存储单元
typedef struct RingBufferItem {
  StuInfo stuInfo; // 学生数据
  int enable;      // 缓存状态（对生产者来说），0可用，1有未处理数据
} *RingBuffer;

/* 创建环形队列 */
RingBuffer init_ringBuffer(int size) {
  RingBuffer ringBuffer;
  if (size &amp;gt; 0) {
    // printf(&amp;quot;struct RingBufferItem size is : %ld\n&amp;quot;, sizeof(struct RingBufferItem));
    ringBuffer = (RingBuffer)malloc(sizeof(RingBufferItem) * size);
    for (int i = 0; i &amp;lt; size; i++) {
      (ringBuffer + i)-&amp;gt;enable = 1;
    }
    return ringBuffer;
  } else {
    return NULL;
  }
}

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;代码2-生产者-消费者运行模型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;quot;ringBuffer.h&amp;quot;

/* 缓存容量*/
#define MAX_COUNT 5
/* 测试并发量 */
#define TEST_COUNT 10;
/* 定义环形数组 */
RingBuffer ringBuffer;
/* 定义requestID（自增ID） */
int requestID; // 生产者请求序号
/* 定义互斥锁 */
pthread_mutex_t mutex_for_requestID;
pthread_mutex_t mutex_for_ringBuffer;
/* 为消费者定义已处理请求数，作为消费者循环处理数据的判断 */
int requestDone; // 消费者处理序号

/* --- methods --- */

/* 计算环形队列的索引号 */
int getRingBufferIndex(int request_index);
/* 生产者 */
void *eventFactory_start(void *myvar);
/* 消费者 */
void *eventHandler_start(void *myvar);
/* 加锁 */
void my_pthread_mutex_lock(pthread_mutex_t *mutex);


int main(int argc, char *argv[]){

  // printf(&amp;quot;%d\n&amp;quot;, getRingBufferIndex(requestID++));
  // exit(0);

  // 初始化锁
  pthread_mutex_init(&amp;amp;mutex_for_requestID, NULL);
  pthread_mutex_init(&amp;amp;mutex_for_ringBuffer, NULL);
  // 初始化环形队列
  // 浅拷贝返回值
  ringBuffer = init_ringBuffer(MAX_COUNT);
  requestID = -1;
  requestDone = -1;
  // for(int i = 0; i &amp;lt; MAX_COUNT; i++) {
  //   printf(&amp;quot;buffer[%d].enable = %d\n&amp;quot;, i, (ringBuffer + i)-&amp;gt;enable);
  // }

  pthread_t thread1, thread2;
  // pthread_t	thread3, thread4;

  int ret1, ret2;

  ret1 = pthread_create(&amp;amp;thread1, NULL, eventFactory_start, NULL);
  ret2 = pthread_create(&amp;amp;thread2, NULL, eventHandler_start, NULL);

  pthread_join(thread1, NULL);
  pthread_join(thread2, NULL);

  // sleep(1);
  // ret1 = pthread_create(&amp;amp;thread3, NULL, eventFactory_start, NULL);
  // ret2 = pthread_create(&amp;amp;thread4, NULL, eventHandler_start, NULL);
  // pthread_join(thread3, NULL);
  // pthread_join(thread4, NULL);

  printf(&amp;quot;producer thread ret1 = %d\n&amp;quot;, ret1);
  printf(&amp;quot;consumer thread ret2 = %d\n&amp;quot;, ret2);

  return 0;
}

/* 计算环形队列的索引号 */
int getRingBufferIndex(int request_index) {
  return request_index % MAX_COUNT;
}

/* 加锁 */
void my_pthread_mutex_lock(pthread_mutex_t *mutex) {
  if (pthread_mutex_lock(mutex) != 0){
    printf(&amp;quot;lock error!\n&amp;quot;);
    exit(0);
  }
}

/* 生产者 */
void *eventFactory_start(void *myvar) {
  // 并发放入1000个测试数据
  for(int i = 0; i &amp;lt; 15; i++) {
    // --- mock数据生成开始 ---
    char *stu_name = (char*)malloc(sizeof(char) * 64);
    char *stu_stuID = (char*)malloc(sizeof(char) * 64);
    sprintf(stu_name, &amp;quot;姓名[%d]&amp;quot;, i);
    sprintf(stu_stuID, &amp;quot;ID[%d]&amp;quot;, i);
    // printf(&amp;quot;姓名 = %s\n&amp;quot;, stu_name);
    // printf(&amp;quot;ID = %s\n&amp;quot;, stu_stuID);
    int age = i;
    // --- mock数据生成结束 ---
    // requestID 加锁
    my_pthread_mutex_lock(&amp;amp;mutex_for_requestID);
    requestID++;
    int current_requestID = requestID;
    // ringBuffer 加锁
    my_pthread_mutex_lock(&amp;amp;mutex_for_ringBuffer);
    // printf(&amp;quot;current_requestID = %d\n&amp;quot;, current_requestID);
    int ringBufferIndex = getRingBufferIndex(current_requestID);
    if((ringBuffer + ringBufferIndex)-&amp;gt;enable == 0) {
      printf(&amp;quot;☒ 并发数达到最大，已丢弃请求学生(%s)创建的请求\n&amp;quot;, stu_name);
      requestID--;
      // requestID 解锁
      pthread_mutex_unlock(&amp;amp;mutex_for_requestID);
    } else {
      // requestID 解锁
      pthread_mutex_unlock(&amp;amp;mutex_for_requestID);
      // 向缓存添加模拟数据
      (ringBuffer + ringBufferIndex)-&amp;gt;stuInfo.stu_name = stu_name;
      (ringBuffer + ringBufferIndex)-&amp;gt;stuInfo.stu_stuID = stu_stuID;
      (ringBuffer + ringBufferIndex)-&amp;gt;stuInfo.age = age;
      (ringBuffer + ringBufferIndex)-&amp;gt;enable = 0;
      printf(&amp;quot;→ 学生(%s)已创建任务\n&amp;quot;, (ringBuffer + ringBufferIndex)-&amp;gt;stuInfo.stu_name);
    }
    // ringBuffer 解锁
    pthread_mutex_unlock(&amp;amp;mutex_for_ringBuffer);
  }
}

/* 消费者 */
void *eventHandler_start(void *myvar) {
  int timeout_count = 10;
  int current_timeout_count = 0;
  while(1) {
    // requestID 加锁
    my_pthread_mutex_lock(&amp;amp;mutex_for_requestID);
    if (requestDone &amp;lt; requestID) { // 读requestID暂不加锁
      // requestID 解锁
      pthread_mutex_unlock(&amp;amp;mutex_for_requestID);
      // 有新请求处理
      requestDone++;
      int ringBufferIndex = getRingBufferIndex(requestDone);
      // ringBuffer 加锁
      my_pthread_mutex_lock(&amp;amp;mutex_for_ringBuffer);
      // 数据处理，假装 insert into table...
      sleep(0.001);
      printf(&amp;quot;☑ 学生(%s)已插入数据表!\n&amp;quot;, (ringBuffer + ringBufferIndex)-&amp;gt;stuInfo.stu_name);
      (ringBuffer + ringBufferIndex)-&amp;gt;enable = 1;
      // ringBuffer 解锁
      pthread_mutex_unlock(&amp;amp;mutex_for_ringBuffer);
    } else {
      // requestID 解锁
      pthread_mutex_unlock(&amp;amp;mutex_for_requestID);
      // 消费者休息50ms
      sleep(0.05);
      // current_timeout_count++;
      // if (timeout_count == current_timeout_count) {
      //   break;
      // }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当并发请求数 &amp;lt;= 缓存最大容量时（模拟某一时间点小股并发）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1166" data-height="105" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200408155224.png" alt="" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;当并发请求数 &amp;gt; 缓存最大容量时（模拟某一时间点大量并发）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1171" data-height="480" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200408155145.png" alt="" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;当连续两次有较长时间间隔(相隔1s)的&lt;code&gt;并发请求数 &amp;gt; 缓存最大容量&lt;/code&gt;，时（模拟两个较长时间间隔的大量并发，用来测试环形缓存是否为环状、同一块缓存是否复用）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1166" data-height="493" src="https://cdn.jsdelivr.net/gh/billwhite246/myPicBedRepo@master/img/20200408155336.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zhidao.baidu.com/question/547417688.html"&gt;特殊文字图标符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/huangjh2017/article/details/60776855"&gt;Linux线程同步之——互斥量(Mutex)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/wypblog/article/details/7264315"&gt;linux中的C里面使用pthread_mutex_t锁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href="https://blog.webpro.ltd/"&gt;&lt;a href="https://blog.webpro.ltd"&gt;https://blog.webpro.ltd&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/unix_network/</guid><pubDate>Tue, 08 Sep 2020 07:53:00 +0806</pubDate></item><item><title>用户不在sudoers文件中</title><link>/archives/sudoers/</link><description>&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;将用户添加至&lt;code&gt;sudoers&lt;/code&gt;中&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;root&lt;/code&gt;连接&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;chmod 640 /etc/sudoers

vi /etc/sudoers

#添加用户名至sudoers中去

:wq

chmod 440 /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="639" data-height="157" src="https://cdn.jsdelivr.net/gh/ZGGSONG/zggsong.github.io@master/archives/assets/dd83680010c40c60d66486180ca0dd8f.png" alt="sudoers" /&gt;&lt;figcaption&gt;sudoers&lt;/figcaption&gt;&lt;/figure&gt;</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/sudoers/</guid><pubDate>Fri, 11 Sep 2020 22:13:00 +0806</pubDate></item><item><title>数据结构</title><link>/archives/data_struct/</link><description>&lt;h1&gt;数据结构&lt;/h1&gt;
&lt;h2&gt;第一章：数据结构的&lt;/h2&gt;
&lt;p&gt;基本概念&lt;/p&gt;&lt;h3&gt;定义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;逻辑结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的&lt;/li&gt;
&lt;li&gt;数据的逻辑结构分为线性结构和非线性结构&lt;ul&gt;
&lt;li&gt;集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合&lt;/li&gt;
&lt;li&gt;线性结构 结构中的数据元素之间只存在一对一的关系。比如排队&lt;/li&gt;
&lt;li&gt;树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱&lt;/li&gt;
&lt;li&gt;图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;物理结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。&lt;ul&gt;
&lt;li&gt;顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）&lt;/li&gt;
&lt;li&gt;链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。&lt;/li&gt;
&lt;li&gt;索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。&lt;/li&gt;
&lt;li&gt;散列存储：通过关键字直接计算出元素的物理地址（以后详解）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;算法的五个特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1，有穷性：有限步之后结束&lt;/li&gt;
&lt;li&gt;2，确定性：不存在二义性，即没有歧义&lt;/li&gt;
&lt;li&gt;3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。&lt;/li&gt;
&lt;li&gt;4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。&lt;/li&gt;
&lt;li&gt;5，输出：一至多个程序输出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;算法的复杂度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;ul&gt;
&lt;li&gt;• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；&lt;/li&gt;
&lt;li&gt;• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级&lt;/li&gt;
&lt;li&gt;• T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;ul&gt;
&lt;li&gt;• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；&lt;/li&gt;
&lt;li&gt;• 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;概要: 复杂度计算为重点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常用的时间复杂度大小关系：&lt;/li&gt;
&lt;li&gt;复杂度如何计算&lt;ul&gt;
&lt;li&gt;时间复杂度计算（单个循环体）&lt;ul&gt;
&lt;li&gt;直接关注循环体的执行次数，设为k&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度计算（多个循环体）&lt;ul&gt;
&lt;li&gt;两个运算规则：乘法规则，加法规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第二章：线性表&lt;/h2&gt;
&lt;h3&gt;线性表的逻辑结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表&lt;/li&gt;
&lt;li&gt;特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除第一个元素外，每个元素有且仅有一个直接前驱。
除最后一个元素外，每个元素有且仅有一个直接后继。&lt;/p&gt;&lt;h3&gt;线性表的顺序存储结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;线性表的顺序存储又称为顺序表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻
辑上相邻的两个元素在物理位置上也相邻。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;建立顺序表的三个属性:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.存储空间的起始位置（数组名data）
2.顺序表最大存储容量（MaxSize）
3.顺序表当前的长度（length）&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配&lt;/li&gt;
&lt;li&gt;总结：&lt;ul&gt;
&lt;li&gt;1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。&lt;/li&gt;
&lt;li&gt;2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）&lt;/li&gt;
&lt;li&gt;3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;顺序表的操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.插入&lt;ul&gt;
&lt;li&gt;算法思路：&lt;ul&gt;
&lt;li&gt;1.判断i的值是否正确&lt;/li&gt;
&lt;li&gt;2.判断表长是否超过数组长度&lt;/li&gt;
&lt;li&gt;3.从后向前到第i个位置，分别将这些元素都向后移动一位&lt;/li&gt;
&lt;li&gt;4.将该元素插入位置i 并修改表长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;li&gt;分析：&lt;ul&gt;
&lt;li&gt;最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。&lt;/li&gt;
&lt;li&gt;最坏情况：在表头插入（即i=1），元素后移语句将执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;n次，时间复杂度为O(n)。
        * 平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入
一个结点的概率，则在长度为n的线性表中插入一个结
点时所需移动结点的平均次数为&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;2.删除&lt;ul&gt;
&lt;li&gt;算法思路：&lt;ul&gt;
&lt;li&gt;1.判断i的值是否正确&lt;/li&gt;
&lt;li&gt;2.取删除的元素&lt;/li&gt;
&lt;li&gt;3.将被删元素后面的所有元素都依次向前移动一位&lt;/li&gt;
&lt;li&gt;4.修改表长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;li&gt;分析&lt;ul&gt;
&lt;li&gt;最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。&lt;/li&gt;
&lt;li&gt;最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;线性表的链式存储结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。&lt;/li&gt;
&lt;li&gt;头结点和头指针的区别？&lt;ul&gt;
&lt;li&gt;不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么要设置头结点？&lt;ul&gt;
&lt;li&gt;1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了&lt;/li&gt;
&lt;li&gt;2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;单链表的操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.头插法建立单链表：&lt;ul&gt;
&lt;li&gt;建立新的结点分配内存空间，将新结点插入到当前链表的表头&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.尾插法建立单链表：&lt;ul&gt;
&lt;li&gt;建立新的结点分配内存空间，将新结点插入到当前链表的表尾&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.按序号查找结点&lt;ul&gt;
&lt;li&gt;在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4.按值查找结点&lt;ul&gt;
&lt;li&gt;从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5．插入&lt;ul&gt;
&lt;li&gt;插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。&lt;/li&gt;
&lt;li&gt;算法思路：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.取指向插入位置的前驱结点的指针
① p=GetElem(L,i-1);
2.令新结点&lt;em&gt;s的指针域指向&lt;/em&gt;p的后继结点
② s-&amp;gt;next=p-&amp;gt;next;
3.令结点&lt;em&gt;p的指针域指向新插入的结点&lt;/em&gt;s
③ p-&amp;gt;next=s;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;6．删除&lt;ul&gt;
&lt;li&gt;删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。&lt;/li&gt;
&lt;li&gt;算法思路：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);
2.取指向删除位置的指针 q=p-&amp;gt;next;
3.p指向结点的后继指向被删除结点的后继 p-&amp;gt;next=q-&amp;gt;next
4.释放删除结点 free(q);&lt;/p&gt;&lt;h3&gt;双链表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;1.插入：(方法不唯一)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;① s-&amp;gt;next=p-&amp;gt;next;
② p-&amp;gt;next-&amp;gt;prior=s;
③ s-&amp;gt;prior=p;
④ p-&amp;gt;next=s;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;2.删除：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;① p-&amp;gt;next=q-&amp;gt;next;
② q-&amp;gt;next-&amp;gt;prior=p;
③ free(q);&lt;/p&gt;&lt;h3&gt;循环链表&amp;amp;&amp;amp;静态链表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环&lt;/li&gt;
&lt;li&gt;循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环&lt;ul&gt;
&lt;li&gt;当循环双链表为空表时，其头结点的prior域和next域都等于Head。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态链表：静态链表是用数组来描述线性表的链式存储结构。&lt;ul&gt;
&lt;li&gt;数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三章：栈和队列&lt;/h2&gt;
&lt;h3&gt;栈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;栈（Stack）：只允许在一端进行插入或删除操作的线性表。&lt;/li&gt;
&lt;li&gt;栈顶（Top）：线性表允许进行插入和删除的那一端。&lt;/li&gt;
&lt;li&gt;栈底（Bottom）：固定的，不允许进行插入和删除的另一端&lt;/li&gt;
&lt;li&gt;特点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.栈是受限的线性表，所以自然具有线性关
系。
2.栈中元素后进去的必然先出来，即后进先出
LIFO（Last In First Out）
    * 栈中元素后进
去的必然先出
来，即后进先
出LIFO（Last In
First Out）&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;顺序栈&lt;ul&gt;
&lt;li&gt;栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。&lt;/li&gt;
&lt;li&gt;顺序栈的操作&lt;ul&gt;
&lt;li&gt;1.判空：&lt;/li&gt;
&lt;li&gt;2.进栈：&lt;/li&gt;
&lt;li&gt;3.出栈：&lt;/li&gt;
&lt;li&gt;4.读取栈顶元素：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享栈&lt;ul&gt;
&lt;li&gt;顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享&lt;/li&gt;
&lt;li&gt;示意图&lt;/li&gt;
&lt;li&gt;共享栈的结构&lt;/li&gt;
&lt;li&gt;共享栈的操作：（进栈）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链式栈&lt;ul&gt;
&lt;li&gt;栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。&lt;/li&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.链栈一般不存在栈满的情况。
2.空栈的判定条件通常定为top==NULL；
    * 结构
    * 链式栈的操作
        * 1.进栈
        * 2.出栈&lt;/p&gt;&lt;h3&gt;队列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;队列是只允许在一端进行插入，而在另一端进行删除的线性表&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队头（Front）：允许删除的一端，又称为队首。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队尾（Rear）： 允许插入的一端。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顺序队列&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;用数组来实现队列，可以将队首放在数组下标为0的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;循环队列&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列&lt;/li&gt;
&lt;li&gt;入队：rear=(rear+1)%MaxSize&lt;/li&gt;
&lt;li&gt;出队：front=(front+1)%MaxSize&lt;/li&gt;
&lt;li&gt;循环队列的操作&lt;ul&gt;
&lt;li&gt;1.入队：&lt;/li&gt;
&lt;li&gt;2.出队：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概要: 那如何分辨队列是空还是满呢？&lt;ul&gt;
&lt;li&gt;方法一：设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满。&lt;/li&gt;
&lt;li&gt;方法二：我们把front=rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链式队列&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链式队列的操作&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双端队列&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;双端队列是指允许两端都可以进行入队和出队操作的队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;栈的应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、表达式求值：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、递归：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;要理解递归，你要先理解递归，直到你能理解递归。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。
    * 1.阶乘
        * 时间复杂度：O(NlogN)
    * 2.斐波那契数列
        * 时间复杂度   O(2^n)&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;概要: 如何将中缀表达式转换成后缀表达式？&lt;ul&gt;
&lt;li&gt;1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)&lt;/li&gt;
&lt;li&gt;2.把运算符移到对应的括号后。&lt;/li&gt;
&lt;li&gt;3.去掉括号。&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第四章：树&lt;/h2&gt;
&lt;h3&gt;树的基本概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;树是递归定义的结构&lt;/li&gt;
&lt;li&gt;结点&lt;ul&gt;
&lt;li&gt;根节点：树只有一个根结点&lt;/li&gt;
&lt;li&gt;结点的度：结点拥有的子树的数量&lt;ul&gt;
&lt;li&gt;度为0：叶子结点或者终端结点&lt;/li&gt;
&lt;li&gt;度不为0：分支结点或者非终端结点&lt;ul&gt;
&lt;li&gt;分支结点除去根结点也称为内部结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;树的度：树中所有结点的度数的最大值&lt;/li&gt;
&lt;li&gt;结点关系&lt;ul&gt;
&lt;li&gt;祖先结点&lt;ul&gt;
&lt;li&gt;根结点到该结点的唯一路径的任意结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子孙结点&lt;/li&gt;
&lt;li&gt;双亲结点&lt;ul&gt;
&lt;li&gt;根结点到该结点的唯一路径上最接近该结点的结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;孩子结点&lt;/li&gt;
&lt;li&gt;兄弟结点&lt;ul&gt;
&lt;li&gt;有相同双亲结点的结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;层次，高度，深度，树的高度&lt;ul&gt;
&lt;li&gt;层次：根为第一层，它的孩子为第二层，以此类推&lt;/li&gt;
&lt;li&gt;结点的深度：根结点开始自顶向下累加&lt;/li&gt;
&lt;li&gt;结点的高度：叶节点开始自底向上累加&lt;/li&gt;
&lt;li&gt;树的高度（深度）：树中结点的最大层数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;树的性质&lt;ul&gt;
&lt;li&gt;1.树中的结点数等于所有结点的度数加1。&lt;ul&gt;
&lt;li&gt;证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n=b+1。而分支数b也就是所有结点的度数，证毕。
    * 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。
        * 证明：（数学归纳法）
首先考虑i=1的情况：第一层只有根结点，即一个结点，i=1带入式子满足。
假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。
……… ..........
i-1层
………
又因为树的度为m,所以对于第i-1层的每个结点，最多
有m个孩子结点。所以第i层的结点数最多是i-1层的m
倍，所以第i层上最多有m ^(i-1)个结点。
    * 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点
    * 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1)&lt;/p&gt;&lt;h3&gt;树的存储结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;顺序存储结构&lt;ul&gt;
&lt;li&gt;双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链式存储结构&lt;ul&gt;
&lt;li&gt;孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是叶子结点，那这个结点的孩子单链表就是空的；
然后n个单链表的的头指针又存储在一个顺序表（数组）中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;点的第一个孩子结点和这个孩子结点的右兄弟结点。&lt;/p&gt;&lt;h3&gt;二叉树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;ul&gt;
&lt;li&gt;二叉树是n（n≥0）个结点的有限集合：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;① 或者为空二叉树，即n=0。
② 或者由一个根结点和两个互不相交的被称为根的左子树
和右子树组成。左子树和右子树又分别是一棵二叉树。 
        * 1.每个结点最多有两棵子树。
        * 2.左右子树有顺序&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;二叉树的五种基本形态：&lt;ul&gt;
&lt;li&gt;1.空树&lt;/li&gt;
&lt;li&gt;2.只有一个根结点&lt;/li&gt;
&lt;li&gt;3.根结点只有左子树&lt;/li&gt;
&lt;li&gt;4.根结点只有右子树&lt;/li&gt;
&lt;li&gt;5.根结点既有左子树又有右子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊二叉树&lt;ul&gt;
&lt;li&gt;1.斜树&lt;/li&gt;
&lt;li&gt;2.满二叉树:&lt;/li&gt;
&lt;li&gt;3.完全二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二叉树的性质&lt;ul&gt;
&lt;li&gt;1.非空二叉树上叶子结点数等于度为2的结点数加1&lt;/li&gt;
&lt;li&gt;2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）&lt;/li&gt;
&lt;li&gt;3.高度为H的二叉树至多有2^H-1个结点（H≥1）&lt;/li&gt;
&lt;li&gt;4.具有N个（N&amp;gt;0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉树的存储结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;顺序存储&lt;ul&gt;
&lt;li&gt;二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链式存储&lt;ul&gt;
&lt;li&gt;二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉树的遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）访问根结点；
2）先序遍历左子树；
3）先序遍历右子树。
    * 递归
    * 非递归&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;中序遍历：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）中序遍历左子树；
2）访问根结点；
3）中序遍历右子树。
    * 递归
    * 非递归&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;后序遍历：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）后序遍历左子树；
2）后序遍历右子树；
3）访问根结点。
    * 递归
    * 非递归&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;层次遍历：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若树为空，则什么都不做直接返回。
否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。&lt;/p&gt;&lt;h3&gt;线索二叉树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;N个结点的二叉链表，每个结点都有指向左右孩子的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结点指针，所以一共有2N个指针，而N个结点的二叉
树一共有N-1条分支，也就是说存在2N-(N-1)=N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空
指针。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;大量的空余指针能否利用起来？&lt;ul&gt;
&lt;li&gt;指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树&lt;/li&gt;
&lt;li&gt;对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;哈夫曼树和哈夫曼编码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;算法的描述如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。
2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值
置为左、右子树上根结点的权值之和。
3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
4）重复步骤2）和3），直至F中只剩下一棵树为止。&lt;/p&gt;&lt;h2&gt;第五章：图&lt;/h2&gt;
&lt;h3&gt;图的基本概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树是N（N≥0）个结点的有限集合，N=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：
1）有且仅有一个特定的称为根的结点。
2）当N&amp;gt;1时，其余结点可分为m（m&amp;gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。
    * 图G由顶点集V和边集E组成，记为G=(V，E)
        * V(G)表示图G中顶点的有限非空集。
用|V|表示图G中顶点的个数，也称为图G的阶
        * E(G)表示图G中顶点之间的关系（边）集合。
用|E|表示图G中边的条数。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;分类&lt;ul&gt;
&lt;li&gt;有向图&lt;ul&gt;
&lt;li&gt;有向边（弧）的有限集合&lt;ul&gt;
&lt;li&gt;弧是顶点的有序对&lt;/li&gt;
&lt;li&gt;&amp;lt;v,w&amp;gt;&lt;/li&gt;
&lt;li&gt;v是弧尾，w是弧头&lt;/li&gt;
&lt;li&gt;v邻接到w或w邻接自v&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无向图&lt;ul&gt;
&lt;li&gt;无向边的有限集合&lt;ul&gt;
&lt;li&gt;边是顶点的无序对&lt;/li&gt;
&lt;li&gt;（v,w）&lt;/li&gt;
&lt;li&gt;（v,w）=(w,v)&lt;/li&gt;
&lt;li&gt;w，v互为邻接点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;简单图&lt;ul&gt;
&lt;li&gt;1.不存在顶点到自身的边&lt;/li&gt;
&lt;li&gt;2.同一条边不重复出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多重图&lt;ul&gt;
&lt;li&gt;若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完全图&lt;ul&gt;
&lt;li&gt;无向完全图&lt;ul&gt;
&lt;li&gt;如果任意两个顶点之间都存在边&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有向完全图&lt;ul&gt;
&lt;li&gt;如果任意两个顶点之间都存在方向相反的两条弧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子图&lt;/li&gt;
&lt;li&gt;连通图：图中任意两个顶点都是连通的&lt;/li&gt;
&lt;li&gt;连通分量：无向图中的极大连通子图&lt;ul&gt;
&lt;li&gt;连通&lt;ul&gt;
&lt;li&gt;顶点A到顶点B有路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;极大&lt;ul&gt;
&lt;li&gt;1.顶点足够多&lt;/li&gt;
&lt;li&gt;2.极大连通子图包含这些依附这些顶点的所有边&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。&lt;/li&gt;
&lt;li&gt;概要: 找连通分量的方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;强连通：顶点V到顶点W和顶点W到顶点V都有路径&lt;/li&gt;
&lt;li&gt;强连通图：图中任一对顶点都是强连通的&lt;/li&gt;
&lt;li&gt;连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图&lt;ul&gt;
&lt;li&gt;结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;度：以该顶点为一个端点的边数目&lt;ul&gt;
&lt;li&gt;无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)&lt;/li&gt;
&lt;li&gt;有向图中顶点V的度分为出度和入度&lt;ul&gt;
&lt;li&gt;入度（ID）是以顶点v为终点的有向边的数目&lt;/li&gt;
&lt;li&gt;出度（OD）是以顶点V为起点的有向边的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路&lt;/li&gt;
&lt;li&gt;权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网&lt;/li&gt;
&lt;li&gt;路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度&lt;/li&gt;
&lt;li&gt;回路（环）：第一个和最后一个顶点相同的路径称为回路或者环&lt;/li&gt;
&lt;li&gt;距离：从顶点u到v的最短路径长度。不存在路径则为无穷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图的存储结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵（顺序存储）&lt;/li&gt;
&lt;li&gt;邻接表（链式存储）&lt;ul&gt;
&lt;li&gt;十字链表（有向图）&lt;/li&gt;
&lt;li&gt;邻接多重表（无向图）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图的遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;深度优先遍历&lt;ul&gt;
&lt;li&gt;深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法&lt;ul&gt;
&lt;li&gt;空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)&lt;/li&gt;
&lt;li&gt;时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)
            2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广度优先遍历&lt;ul&gt;
&lt;li&gt;广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法&lt;ul&gt;
&lt;li&gt;空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。&lt;/li&gt;
&lt;li&gt;时间复杂度：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)
2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)&lt;/p&gt;&lt;h3&gt;图的应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最小生成树&lt;ul&gt;
&lt;li&gt;普利姆（Prlm）&lt;ul&gt;
&lt;li&gt;①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。&lt;/li&gt;
&lt;li&gt;②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。&lt;/li&gt;
&lt;li&gt;③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。&lt;/li&gt;
&lt;li&gt;④反复执行②③直到所有所有顶点都加入到生成树中。&lt;/li&gt;
&lt;li&gt;概要:&lt;ul&gt;
&lt;li&gt;双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且时间复杂度只和n有关，所以适合稠密图
    * 克鲁斯卡尔（Kruskal）
        * 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。
        * 概要:&lt;br /&gt;
            * 
            *&lt;br /&gt;
            * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;最短路径&lt;ul&gt;
&lt;li&gt;迪杰斯特拉&lt;ul&gt;
&lt;li&gt;一个源点到其余顶点的最短路径&lt;ul&gt;
&lt;li&gt;该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]=1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。
path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。&lt;/p&gt;&lt;p&gt;假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&amp;lt;i，j&amp;gt;的权值，若不存在有向边&amp;lt;i，j&amp;gt;，则arcs[i][j]为∞。Dijkstra算法的步骤如下：
1）初始化：集合S初始为{0}，dist[]的初始值dist[i]=arcs[0][i]，i=1，2，…，n-1。
2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]=1。
3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]&amp;lt; dist[k]，则令dist[k]=dist[j] + arcs[j][k]。另外更新path[k]=j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)
4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。
    * 弗洛伊德
        * 所有顶点到所有顶点的最短路径
            * 算法思想：
递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)
其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径
    * 非带权图
        * 两点之间经过边数最少的路径
    * 带权图
        * 两点之间经过的边上权值之和最小的路径&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拓扑排序&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AOV&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；
如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。
    * 拓扑排序算法：
     从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;关键路径&lt;ul&gt;
&lt;li&gt;AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第六章：查找&lt;/h2&gt;
&lt;h3&gt;查找的基本概念和顺序查找&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找&lt;/li&gt;
&lt;li&gt;关键字：数据元素中某个可以以唯一标识该元素的数据项&lt;/li&gt;
&lt;li&gt;平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值&lt;/li&gt;
&lt;li&gt;顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;li&gt;4&lt;/li&gt;
&lt;li&gt;时间复杂度为O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;折半查找&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;算法思路：&lt;ul&gt;
&lt;li&gt;首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;折半查找分析&lt;ul&gt;
&lt;li&gt;折半查找判定树&lt;ul&gt;
&lt;li&gt;对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数&lt;/li&gt;
&lt;li&gt;时间复杂度为O(logn)&lt;/li&gt;
&lt;li&gt;概要: 具有N个（N&amp;gt;0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分块查找&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分块查找又称为索引顺序查找&lt;/li&gt;
&lt;li&gt;分块查找思想：&lt;ul&gt;
&lt;li&gt;①确定待查找值在哪个块（折半查找）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;②在确定的块中查找待查找值（顺序查找）&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;分块查找分析&lt;ul&gt;
&lt;li&gt;由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即ASL分块=ASL折半+ASL顺序
        *&lt;/p&gt;&lt;h3&gt;二叉排序树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。
②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。
③它的左右子树也是一棵二叉排序树。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;算法思想&lt;ul&gt;
&lt;li&gt;由于二叉排序树的特点(左子树&amp;lt;根结点&amp;lt;右子树),所以每次查找一个关键字，需要先和根结点进行比较：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。
如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。
        * 查找关键字代码
            * 1 
            * 2
        * 插入关键字代码
            * 1)空树：直接插入新结点返回成功
2)树不空：检查是否存在关键字重复的结点：
①存在：返回插入失败
②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树
            *&lt;br /&gt;
        * 构造代码
            *&lt;br /&gt;
        * 删除结点
            * ①删除的是叶子结点
                * 方法：直接删去该结点即可
            * ②删除的是仅有左子树或者右子树的结点
                * 方法：“子承父业”
            * ③删除的是左右子树都有的结点
                * 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子
方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;二叉排序树分析&lt;ul&gt;
&lt;li&gt;查找时间复杂度是O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概要: “左小右大”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;平衡二叉树(AVL树)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平衡因子&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平衡调整&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;LL调整(左孩子的左子树上插入结点导致)&lt;ul&gt;
&lt;li&gt;最小不平衡子树根结点的平衡因子为2&amp;gt;0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的左孩子结点平衡因子为1&amp;gt;0
两个都大于0，所以直接右旋就可以调整
            * 概要: “正则右旋”
        * RR调整(右孩子的右子树上插入结点导致)
            *  最小不平衡子树根结点的平衡因子为-2&amp;lt;0
它的右孩子结点平衡因子为-1&amp;lt;0
两个都小于0，所以直接左旋就可以调整
            * 概要: “负则左旋”
        * LR调整(左孩子的右子树上插入结点导致)
        * RL调整(右孩子的左子树上插入结点导致)
        * 概要: 先局部转换为LL或RR，最后进行调整&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;分析&lt;ul&gt;
&lt;li&gt;含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;B树和B+树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2-3树&lt;ul&gt;
&lt;li&gt;2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点&lt;ul&gt;
&lt;li&gt;1)2结点包含一个元素和两个孩子(或者没有孩子)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值
  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子
      * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)
  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。
  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子
      * 3)2-3树所有叶子结点都在同一层次&lt;/li&gt;
&lt;li&gt;2-3-4树&lt;ul&gt;
&lt;li&gt;2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点&lt;ul&gt;
&lt;li&gt;1)2结点包含一个元素和两个孩子(或者没有孩子)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值
  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子
      * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。
  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。
  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子
      * 3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。
  ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。&lt;br /&gt;
  ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子
      * 4)2-3-4树所有叶子结点都在同一层次&lt;/li&gt;
&lt;li&gt;B树&lt;ul&gt;
&lt;li&gt;B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一棵m阶B树或为空树，或为满足如下特性的m叉树：
        * 1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (&amp;quot;两棵子树指针夹着一个关键字&amp;quot;)
        * 2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)
        * 3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字）
        * 4）所有非叶结点的结构如下：
        * 5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)
    * 1.B树的查找操作
        * 查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。
                  ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。
                      Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 2.B树的插入操作
    * 分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。
* 3.B树的删除操作
    * B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。
        * 1）如果删除的关键字在终端结点上（最底层非叶子结点）：
  ①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。
  ②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。
  ③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。

        * 2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。
            * 相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。
            * 第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。
            * 第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;B+树&lt;ul&gt;
&lt;li&gt;B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构&lt;/li&gt;
&lt;li&gt;m阶的B+树与m阶的B树的主要差异在于：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。
2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。
3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。&lt;/p&gt;&lt;h3&gt;散列表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。&lt;/li&gt;
&lt;li&gt;散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。&lt;/li&gt;
&lt;li&gt;散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。&lt;/li&gt;
&lt;li&gt;构造散列函数的tips：&lt;ul&gt;
&lt;li&gt;1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。&lt;/li&gt;
&lt;li&gt;2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。&lt;/li&gt;
&lt;li&gt;3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.常用Hash函数的构造方法：&lt;ul&gt;
&lt;li&gt;1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突&lt;/li&gt;
&lt;li&gt;2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性
    * 3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合
    * 4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。
    * 5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;2.常用Hash函数的冲突处理办法：&lt;ul&gt;
&lt;li&gt;1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。&lt;ul&gt;
&lt;li&gt;1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。&lt;/li&gt;
&lt;li&gt;2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22......&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。
        * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。
        * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。
    * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。
    * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。
      先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。
         1)如果没有，表明该关键字不存在，返回查找失败。
         2)如果有，则检查该记录是否等于关键字。
                 ①如果等于关键字，返回查找成功。
                 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。
    * 4.散列表的查找性能：和装填因子有关。
        *&lt;br /&gt;
        * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小&lt;/p&gt;&lt;h2&gt;第七章：排序&lt;/h2&gt;
&lt;h3&gt;排序的基本知识&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义：排序就是将原本无序的序列重新排列成有序的序列。&lt;/li&gt;
&lt;li&gt;排序的稳定性&lt;ul&gt;
&lt;li&gt;如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;插入类排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;直接插入排序&lt;ul&gt;
&lt;li&gt;直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。&lt;/li&gt;
&lt;li&gt;时间复杂度为O(n)&lt;/li&gt;
&lt;li&gt;直接插入排序是稳定性是稳定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;折半插入排序&lt;ul&gt;
&lt;li&gt;折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。&lt;/li&gt;
&lt;li&gt;折半插入排序的时间复杂度为O(n^2)&lt;/li&gt;
&lt;li&gt;稳定性：和直接插入排序稳定性相同，是稳定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;希尔排序&lt;ul&gt;
&lt;li&gt;希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。&lt;ul&gt;
&lt;li&gt;①先以增量5来分割序列，也就是下标为0,5,10,15...的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。&lt;/li&gt;
&lt;li&gt;②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。&lt;/li&gt;
&lt;li&gt;③接下来的第三轮，第四轮...都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。&lt;/li&gt;
&lt;li&gt;概要:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度：...  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)&lt;/li&gt;
&lt;li&gt;空间复杂度：希尔排序的空间复杂度为O(1)&lt;/li&gt;
&lt;li&gt;稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;交换类排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;ul&gt;
&lt;li&gt;假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&amp;gt;A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。&lt;/li&gt;
&lt;li&gt;空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)&lt;/li&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;li&gt;稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速排序&lt;ul&gt;
&lt;li&gt;快速排序是一种基于分治法的排序方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。
        * 1
        * 2
    * 时间复杂度：
最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。
 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。
    * 空间复杂度：
由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。
最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)
最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；
    * 稳定性：快速排序是不稳定的，是因为存在交换关键字。&lt;/p&gt;&lt;h3&gt;选择类排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简单选择排序&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)&lt;/li&gt;
&lt;li&gt;时间复杂度：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次，
对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。
                      当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2)
    * 稳定性：不稳定   原因就在于交换部分会打破相对顺序&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆排序&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是堆？&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。&lt;ul&gt;
&lt;li&gt;如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。&lt;/li&gt;
&lt;li&gt;如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么是堆排序？&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆&lt;/p&gt;&lt;p&gt;堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;堆排序不稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;归并排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例如：49 38 65 97 76 13 27&lt;ul&gt;
&lt;li&gt;①首先将整个序列的每个关键字看成一个单独的有序的子序列&lt;/li&gt;
&lt;li&gt;②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象&lt;/li&gt;
&lt;li&gt;③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}&lt;/li&gt;
&lt;li&gt;④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度：O(nlog2n)&lt;/li&gt;
&lt;li&gt;空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)&lt;/li&gt;
&lt;li&gt;稳定性：稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基数排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。&lt;/li&gt;
&lt;li&gt;例子：53, 3, 542, 748, 14, 214, 154, 63, 616&lt;ul&gt;
&lt;li&gt;补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616&lt;/li&gt;
&lt;li&gt;桶实际是一个队列，先进先出(从桶的上面进，下面出)&lt;/li&gt;
&lt;li&gt;关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)&lt;/li&gt;
&lt;li&gt;时间复杂度：需要进行关键字位数d次&amp;quot;分配&amp;quot;和&amp;quot;收集&amp;quot;，一次&amp;quot;分配&amp;quot;需要将n个关键字放进各个队列中，一次&amp;quot;收集&amp;quot;需要将r个桶都收集一遍。所以一次&amp;quot;分配&amp;quot;和一次&amp;quot;收集&amp;quot;时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。&lt;/li&gt;
&lt;li&gt;稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;外部排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。&lt;/li&gt;
&lt;li&gt;如何得到初始的归并段&lt;ul&gt;
&lt;li&gt;置换选择排序：解决排序段放入内存的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何减少多个归并段的归并次数&lt;ul&gt;
&lt;li&gt;最佳归并树：最少的归并次数（I/O次数）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何每次m路归并快速得到最小的关键字&lt;ul&gt;
&lt;li&gt;败者树：减少比较次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概要: 内存容量无法容纳大量数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;二叉树与树与森林&lt;/h2&gt;
&lt;h3&gt;树与二叉树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如何将一棵树转化成二叉树？&lt;ul&gt;
&lt;li&gt;树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针&lt;ul&gt;
&lt;li&gt;将孩子兄弟表示法理解成二叉链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;树转换成二叉树的手动模拟方法：&lt;ul&gt;
&lt;li&gt;①将同一结点的各个孩子用线串连起来&lt;/li&gt;
&lt;li&gt;②将每个结点的子树分支，从左往右，除了第一个以外全部删除&lt;/li&gt;
&lt;li&gt;概要: 例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何将一棵二叉树转化成树？&lt;ul&gt;
&lt;li&gt;二叉树转换成树的手动模拟方法：&lt;ul&gt;
&lt;li&gt;①将二叉树从上到下分层，并调节成水平方向。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(分层方法：每遇到左孩子则为一层)
        * ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。
例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.
        * ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。
        * 概要: 例子&lt;/p&gt;&lt;h3&gt;森林与二叉树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;森林：森林是m（m≥0）棵互不相交的树的集合&lt;/li&gt;
&lt;li&gt;如何将森林转换成二叉树？&lt;ul&gt;
&lt;li&gt;森林转换成树的手动模拟方法：&lt;ul&gt;
&lt;li&gt;①将森林中每棵树都转换成二叉树&lt;/li&gt;
&lt;li&gt;②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推&lt;/li&gt;
&lt;li&gt;概要: 例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何将二叉树转换成森林？&lt;ul&gt;
&lt;li&gt;二叉树转换成森林的手动模拟方法：&lt;ul&gt;
&lt;li&gt;反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。&lt;/li&gt;
&lt;li&gt;概要: 例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;树与森林的遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求&lt;/li&gt;
&lt;li&gt;后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求&lt;/li&gt;
&lt;li&gt;树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历&lt;/li&gt;
&lt;li&gt;概要: 例子&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="3619" data-height="14920" src="https://cdn.jsdelivr.net/gh/ZGGSONG/zggsong.github.io@master/archives/assets/f6a38eaee1e4c72350171bc6275ba3bc.png" alt="picture" /&gt;&lt;figcaption&gt;picture&lt;/figcaption&gt;&lt;/figure&gt;</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/data_struct/</guid><pubDate>Tue, 13 Oct 2020 22:27:00 +0806</pubDate></item><item><title>Github-DNS污染</title><link>/archives/dnscachepollution/</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;一直发现有这个问题，后来才发现是DNS污染问题，ABROAD也是没用。暂时只能修改&lt;code&gt;hosts&lt;/code&gt;了&lt;/p&gt;&lt;h2&gt;解决&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;打开&lt;a href="https://www.ipaddress.com"&gt;ipaddress.com&lt;/a&gt;查询&lt;code&gt;raw.githubusercontent.com&lt;/code&gt;真实ip&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1035" data-height="331" src="https://cdn.zggsong.cn/2020/04/23/6ea1202e0c596.png" alt="ipaddress" /&gt;&lt;figcaption&gt;ipaddress&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;
&lt;p&gt;linux &amp;amp;&amp;amp; mac&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo vim /etc/hosts
&lt;span class="c1"&gt;#最后一行添加&lt;/span&gt;
&lt;span class="m"&gt;199&lt;/span&gt;.232.68.133    raw.githubusercontent.com
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;刷新DNS缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo dscacheutil -flushcache    &lt;span class="c1"&gt;#mac刷新DNS&lt;/span&gt;
sudo service networking restart     &lt;span class="c1"&gt;#linux刷新DNS&lt;/span&gt;
ipconfig /flushdns     &lt;span class="c1"&gt;#windows刷新DNS&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/dnscachepollution/</guid><pubDate>Tue, 19 Jan 2021 17:26:00 +0806</pubDate></item><item><title>Git</title><link>/archives/git/</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;git仓库使用的基本操作，以及生成使用ssh公钥&lt;/p&gt;&lt;h2&gt;git初始化&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global user.email &lt;span class="s2"&gt;&amp;quot;youremail@domain.com&amp;quot;&lt;/span&gt;
git config --global user.name &lt;span class="s2"&gt;&amp;quot;Your Name&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;#查看&lt;/span&gt;
git config --list
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成SSH公钥&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。先确认是否已经有一个公钥了&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#查看是否存在.ssh文件夹ls -la  ~/&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.ssh
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;创建新的SSH公钥&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ~
ssh-keygen -t rsa -C &lt;span class="s2"&gt;&amp;quot;youremail@domain.com&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;#出现以下结果则说明创建成功&lt;/span&gt;
Generating public/private rsa key pair.
Enter file &lt;span class="k"&gt;in&lt;/span&gt; which to save the key &lt;span class="o"&gt;(&lt;/span&gt;/root/.ssh/id_rsa&lt;span class="o"&gt;)&lt;/span&gt;: &lt;span class="c1"&gt;# 直接回车，则将密钥按默认路径及文件名进行存储。此时也可以输入特定的文件名&lt;/span&gt;
Created directory &lt;span class="s1"&gt;&amp;#39;/root/.ssh&amp;#39;&lt;/span&gt;.
Enter passphrase &lt;span class="o"&gt;(&lt;/span&gt;empty &lt;span class="k"&gt;for&lt;/span&gt; no passphrase&lt;span class="o"&gt;)&lt;/span&gt;:  &lt;span class="c1"&gt;# 根据提示，你需要输入密码和确认密码。可以不填，设置为空值，直接回车&lt;/span&gt;
Enter same passphrase again: 
Your identification has been saved &lt;span class="k"&gt;in&lt;/span&gt; /root/.ssh/id_rsa.
Your public key has been saved &lt;span class="k"&gt;in&lt;/span&gt; /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:yFt14TcP0H+ixy9VKiILPPJ6DVevkKgrbxVFqk7mn5k xxxxxx@126.com
The key&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s randomart image is:
+---&lt;span class="o"&gt;[&lt;/span&gt;RSA &lt;span class="m"&gt;2048&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;----+
&lt;span class="p"&gt;|&lt;/span&gt;            o.   &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;      .    . o.  &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;     o    . o +. &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;    .... ... ..++&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;   . o .So .   o+&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;  + o &lt;span class="nv"&gt;Bo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; . + + .&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;   *.* +   o o &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;  ++o o o .   . .&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="nv"&gt;E&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;++         . &lt;span class="p"&gt;|&lt;/span&gt;
+----&lt;span class="o"&gt;[&lt;/span&gt;SHA256&lt;span class="o"&gt;]&lt;/span&gt;-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;查看生成文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.ssh
ls
&lt;span class="c1"&gt;#显示以下内容&lt;/span&gt;
id_rsa      id_rsa.pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中id_rsa.pub就是公钥&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;测试连接&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh -T git@github.com
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Git 常用命令&lt;/h2&gt;
&lt;h3&gt;仓库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &amp;quot;[name]&amp;quot;
$ git config [--global] user.email &amp;quot;[email address]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;增加/删除文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码提交&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;分支&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;标签&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&amp;quot;提交说明&amp;quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &amp;quot;@{0 day ago}&amp;quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;远程同步&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;撤销&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;其他&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 生成一个可供发布的压缩包
$ git archive
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;以上常用命令来自阮一峰老师的博客文章《常用 Git 命令清单》，感谢阮老师！&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;Git命令速查表&lt;/h2&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="1081" data-height="1921" src="https://cdn.jsdelivr.net/gh/ZGGSONG/zggsong.github.io@master/archives/assets/416e2fbb8e0d7c0505407ef55f76e93a.png" alt="" /&gt;&lt;/figure&gt;</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/git/</guid><pubDate>Thu, 01 Apr 2021 17:27:00 +0806</pubDate></item><item><title>Mac安装配置Redis</title><link>/archives/redis_mac/</link><description>&lt;h2&gt;安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install redis
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;路径&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Homebrew安装的软件会默认在/usr/local/Cellar/路径下&lt;/li&gt;
&lt;li&gt;redis的配置文件redis.conf存放在/usr/local/etc路径下&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;redis默认是前台启动，我们实际开发是以守护进程的方式运行。进入/usr/local/etc路径下，然后vi redis.conf ，找到daemonize no并修改成yes即可。&lt;/li&gt;
&lt;li&gt;找到bind 127.0.01 并且注释掉&lt;/li&gt;
&lt;li&gt;找到requirepass设置密码为：requirepass 【填自己设置的密码】，然后按住esc键输入【:wq】回车保存退出即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;启动服务&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 1
brew services start redis

# 2
redis-server /usr/local/etc/redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;再执行命令：redis-server出现redis图标就说明启动成功了&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;查看服务&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ps axu | grep redis
# 或者
lsof -i tcp:6379
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;启动&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redis-cli

# 或者

redis-cli -h host -p port -a password

host:远程redis服务器host

port:远程redis服务端口

password:远程redis服务密码（无密码的的话就不需要-a参数了）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;关闭&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;正确停止Redis的方式：redis-cli shutdown
强行终止redis：sudo pkill redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;强行终止redis进程可能会导致redis持久化数据丢失，应该避免。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;其他&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 开机启动redis命令
ln -f /usr/local/Cellar/redis/6.2.3/homebrew.mxcl.redis.plist ~/Library/LaunchAgents

# 使用launchctl启动redis server
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist

# 使用配置文件启动redis server
redis-server /usr/local/etc/redis.conf

# 停止redis server的自启动
launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.redis.plist

# 卸载
brew uninstall redis
rm ~/Library/LaunchAgents/homebrew.mxcl.redis.plist
&lt;/code&gt;&lt;/pre&gt;
</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/redis_mac/</guid><pubDate>Mon, 12 Apr 2021 18:17:00 +0806</pubDate></item><item><title>命名规范</title><link>/archives/code_name/</link><description>&lt;h2&gt;Java命名规范&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;项目名称：全部小写&lt;/li&gt;
&lt;li&gt;常量：都用大写。如：public static final String DBDRIVER = “…..”;&lt;/li&gt;
&lt;li&gt;类名：大写开头： 如：public class Person{}&lt;/li&gt;
&lt;li&gt;属性名：小写：如：String personName = “Kayle”;&lt;/li&gt;
&lt;li&gt;方法名：小写：如：public String getPersonName() {return this.personName}&lt;/li&gt;
&lt;li&gt;构造函数名：与类名称一样，所以也是大写开头。&lt;/li&gt;
&lt;li&gt;包名：所有的单词都是小写：如：import java.io.*&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Python命名规范&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模块名：小写字母，单词之间用_分割 如：rivet_detection&lt;/li&gt;
&lt;li&gt;包名：小写字母，单词之间用_分割 如：rivet_detection&lt;/li&gt;
&lt;li&gt;类名：单词首字母大写 如：python class LogRecord(object):&lt;/li&gt;
&lt;li&gt;普通变量：小写字母，单词之间用_分割 如：exc_info&lt;/li&gt;
&lt;li&gt;实例变量：以_开头，小写字母，单词之间用_分割 如:_exc_info，以一个下划线开头的标识符(_xxx)，不能访问的类属性，但可通过类提供的接口进行访问，不会被语句 “from module import *” 语句加载&lt;/li&gt;
&lt;li&gt;私有实例变量：以__开头（2个下划线），小写字母，单词之间用&lt;em&gt;分割 如:\&lt;/em&gt;_private_var ，外部访问会报错&lt;/li&gt;
&lt;li&gt;专有变量 __开头（2个下划线），__结尾（2个下划线），一般为python的自有变量，不要以这种方式命名 如:__doc__ ，是系统定义的，具有特殊意义的标识符&lt;/li&gt;
&lt;li&gt;普通函数：小写字母，单词之间用_分割： 如:get_name()&lt;/li&gt;
&lt;li&gt;私有函数：以__开头（2个下划线），小写字母，单词之间用分割 如:__get_name() ，外部访问会报错.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数命名查询网站&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://unbug.github.io/codelf/"&gt;&lt;a href="http://unbug.github.io/codelf/"&gt;http://unbug.github.io/codelf/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/code_name/</guid><pubDate>Fri, 23 Apr 2021 19:58:00 +0806</pubDate></item><item><title>FCPX快捷键</title><link>/archives/fcpx_shorcut_key/</link><description>&lt;h2&gt;快捷键&lt;/h2&gt;
&lt;h3&gt;素材区&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;精确选择：&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;l&lt;/kbd&gt;：播放&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;k&lt;/kbd&gt;：暂停&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;j&lt;/kbd&gt;：倒放&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;command&lt;/kbd&gt;+&lt;kbd&gt;k&lt;/kbd&gt;：添加标签&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;连续两次&lt;kbd&gt;l&lt;/kbd&gt;和&lt;kbd&gt;j&lt;/kbd&gt;则为倍速播放，三次三倍&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;kbd&gt;i&lt;/kbd&gt;：选择入点&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;o&lt;/kbd&gt;：选择出点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;按&lt;kbd&gt;f&lt;/kbd&gt;加入收藏，按&lt;kbd&gt;Delete&lt;/kbd&gt;，标记为拒绝的，按&lt;kbd&gt;u&lt;/kbd&gt;撤回&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;粗剪
-首先快速预览，将内容加入收藏&lt;/li&gt;
&lt;li&gt;精剪&lt;ul&gt;
&lt;li&gt;在上方筛选中选择个人收藏，然后在选取内容添加到时间线上，提高效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;时间线&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;时间线左侧的索引功能面对较多素材有很好的查找作用&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;kbd&gt;q&lt;/kbd&gt;：将片段加入到时间线，并且连接到主线&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;w&lt;/kbd&gt;：将片段插入到主线当前位置（切开插入片段）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;e&lt;/kbd&gt;：将片段插入到主线尾&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;d&lt;/kbd&gt;：将片段覆盖到主线当前位置（覆盖插入片段长度的内容）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;m&lt;/kbd&gt;：标记，方便音乐踩点或其他作用&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;a&lt;/kbd&gt;：选择快捷键&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;t&lt;/kbd&gt;：修建快捷键（选择移动修改内容，两侧黄线变红则表明到顶端了）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;p&lt;/kbd&gt;：位置快捷键（可让两段视频之间添加黑场）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;h&lt;/kbd&gt;：抓手工具&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;n&lt;/kbd&gt;：打开或关闭吸附功能&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;b&lt;/kbd&gt;：切割（&lt;strong&gt;更常用的是在选中位置然后点击&lt;i class="fa fa-apple"&gt;&lt;/i&gt;进行切割&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;z&lt;/kbd&gt;：放大&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;shift&lt;/kbd&gt;+&lt;kbd&gt;z&lt;/kbd&gt;：充满时间线&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;command&lt;/kbd&gt;+&lt;kbd&gt;-&lt;/kbd&gt;和&lt;kbd&gt;command&lt;/kbd&gt;+&lt;kbd&gt;+&lt;/kbd&gt;：放大和缩小&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;option&lt;/kbd&gt;+&lt;kbd&gt;x&lt;/kbd&gt;：&lt;strong&gt;取消范围选择&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;Delete&lt;/kbd&gt;：删除选中内容（视频的话会留下黑场）&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;退格键&lt;/kbd&gt;：删除选中内容&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;command&lt;/kbd&gt;+&lt;kbd&gt;r&lt;/kbd&gt;：调整速度快捷键&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;shift&lt;/kbd&gt;+&lt;kbd&gt;r&lt;/kbd&gt;：全局渲染&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;option&lt;/kbd&gt;+&lt;kbd&gt;r&lt;/kbd&gt;：自定义调整速率&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;转场插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.lookae.com/tag/fcpx%E8%BD%AC%E5%9C%BA%E6%8F%92%E4%BB%B6/"&gt;FCPX转场插件&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://pan.baidu.com/s/1ESrjV6gCrUxEJwpnVpDgpg"&gt;B站棱尧 Curry&lt;strong&gt;调整层&lt;/strong&gt;插件&lt;/a&gt; 提取码:&lt;code&gt;3u2u&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://pan.baidu.com/s/1Jtttu_QTKJtOWXO2odecWA&amp;amp;shfl=sharepset"&gt;vlog音效素材&lt;/a&gt; 密码:&lt;code&gt;rvqy&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;免费视频素材网站：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.openfootage.net"&gt;https://www.openfootage.net&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.vidsplay.com"&gt;https://www.vidsplay.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www.orangehd.com"&gt;http://www.orangehd.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.splitshire.com"&gt;https://www.splitshire.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.ignitemotion.com"&gt;https://www.ignitemotion.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.videezy.com"&gt;https://www.videezy.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://mazwai.com"&gt;http://mazwai.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.monzoom.com"&gt;https://www.monzoom.com&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www.wedistill.io"&gt;http://www.wedistill.io&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://footagecrate.com"&gt;https://footagecrate.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;大拍档剪辑助手&lt;a href="http://spdpd.net/"&gt;下载地址：&lt;a href="http://spdpd.net/"&gt;http://spdpd.net/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;开启任何来源的代码：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo spctl --master-disable
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;第三方插件实现调色&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;导出中选择添加目的位置可存储当前真为图片格式，方便制作封面&lt;/li&gt;
&lt;/ul&gt;
</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/fcpx_shorcut_key/</guid><pubDate>Sun, 23 May 2021 20:00:00 +0806</pubDate></item><item><title>Windows开启OpenSSH服务端</title><link>/archives/openssh_server_for_win/</link><description>&lt;h2&gt;安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;win+r&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;fodhelper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载&lt;code&gt;openssh服务端&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开&lt;code&gt;服务&lt;/code&gt;，开启&lt;code&gt;openssh server服务&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;img loading="lazy" data-width="527" data-height="424" src="https://cdn.jsdelivr.net/gh/ZGGSONG/zggsong.github.io@master/archives/assets/998520947d8cb0ef42b23eb84bb14451.png" alt="" /&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img loading="lazy" data-width="448" data-height="185" src="https://cdn.jsdelivr.net/gh/ZGGSONG/zggsong.github.io@master/archives/assets/8a0fc3603cc29752e87d26a44dd18da0.png" alt="" /&gt;&lt;/figure&gt;&lt;h2&gt;拓展&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;ssh服务端安装好后即可当作SFTP服务器&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;FTP 基于TCP来传输文件，明文传输用户信息和数据。
SFTP 基于SSH来加密传输文件，可靠性高，可断点续传。
SCP 是基于SSH来加密拷贝文件，但要知道详细目录，不可断点续传。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;Mbps (bits per second)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;bit（位，又名“比特”）：bit的缩写是b，是计算机中的最小数据单位（属于二进制的范畴，其实就是0或者1）
Byte（字节）：Byte的缩写是B，是计算机文件大小的基本计算单位。比如一个字符就是1Byte，如果是汉字，则是2Byte。换算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1B（字节）=8b（位）
  1 KB = 1024 B
  1 MB = 1024 KB
  1 GB = 1024 MB
  1TB = 1024GB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1Mbps = 1Mb/s = 1*1024Kb/s = 1024/8KB/s = 125KB/s&lt;/p&gt;&lt;p&gt;100Mbps = 100Mb/s = 100/8MB/s = 12.5MB/s&lt;br /&gt;
即100M宽带理论上最大下载速度12.5MB/s&lt;/p&gt;</description><author>zggsong@foxmail.com (ZGGSONG)</author><guid isPermaLink="true">/archives/openssh_server_for_win/</guid><pubDate>Tue, 06 Jul 2021 20:00:00 +0806</pubDate></item></channel></rss>